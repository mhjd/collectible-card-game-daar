#+title: notes solidity

cryptozombie


Pour résumer, voici un contrat de base - la première chose que vous devez écrire à chaque fois que vous commencerez un nouveau projet :

#+begin_example
pragma solidity ^0.4.19;

contract HelloWorld {

}

#+end_example



Addition : x + y
Soustraction : x - y
Multiplication : x * y
Division : x / y
Modulo / reste : x % y (par exemple, 13 % 5 est 3, car si vous divisez 13 par 5, le reste est 3)

#+begin_src c

  uint x = 5 ** 2; // égal à 5^2 = 25

  struct Zombie {
    string name;
    uint dna;
  }


  // Tableau avec une longueur fixe de 2 éléments :
    uint[2] fixedArray;
  // Un autre Tableau fixe, qui peut contenir 5 `string` :
  string[5] stringArray;
  // un Tableau dynamique, il n'a pas de taille fixe, il peut continuer de grandir :
  uint[] dynamicArray;
  Person[] people; // Tableau dynamique, on peut en rajouter sans limite.
  Person[] public people; // Vous pouvez déclarer un tableau comme public, et Solidity créera automatiquement une méthode d'accès

  function eatHamburgers(string _name, uint _amount) {

  }

  eatHamburgers("vitalik", 100);

  uint[] numbers;
  numbers.push(5);
  numbers.push(10);
  numbers.push(15);


  function _addToArray(uint _number) private {
    numbers.push(_number);
  }


  // view (vue) veut dire qu'elle va seulement voir des données sans les modifier
  function sayHello() public view returns (string) {

  // fonctions pure : même pas accès à des données de l'application
  function _multiply(uint a, uint b) private pure returns (uint) {
    return a * b;
  }

  //6e91ec6b618bb462a4a6ee5aa2cb0e9cf30f7a052bb467b0ba58b8748c00d2e5
  keccak256("aaaab");
  //b1f078126895a1424524de5321b339ab00408010b7cf0e6ed451514981e58aa9
  keccak256("aaaac");


  uint8 a = 5;
  uint b = 6;
  // renvoie une erreur car a * b renvoie un uint, pas un uint8:
  uint8 c = a * b;
  // Nous devons convertir le type de b en uint8 pour que cela marche :
  uint8 c = a * uint8(b);

 
#+end_src




    Remarque: Par convention (mais ce n'est pas obligatoire), les noms des paramètres des fonctions commencent avec un trait de soulignement (_) afin de les différencier des variables globales. Nous utiliserons cette convention tout au long de notre tutoriel.

Il est donc recommandé de marquer vos fonctions comme private (privées) par défaut, puis de ne rendre public (publiques) seulement les fonctions que vous voulez exposer à tout le monde.

Par convention, le nom des fonction privée commence par _ : 
> function _addToArray(uint _number) private

 


Un _ évènement _ est un moyen pour votre contrat d'indiquer à votre application frontale (front-end) que quelque chose vient d'arriver sur la blockchain, l'application frontale pouvant être «à l'écoute» de certains événements pour prendre des mesures quand ils se produisent.

#+begin_src c
// déclaration de l'évènement
event IntegersAdded(uint x, uint y, uint result);

function add(uint _x, uint _y) public {
  uint result = _x + _y;
  // déclenchement de l'évènement pour indiquer à l'application que la fonction a été appelée :
  IntegersAdded(_x, _y, result);
  return result;
}
#+end_src


mapping (clé valeur)
 mapping (uint => address) public zombieToOwner;

En Solidity, il existe des variables globales accessibles à toutes les fonctions. L'une d'elles est msg.sender, qui faire référence à l'address de la personne (ou du smart contract) qui a appelée la fonction actuelle.


require (cond); vérifie si cond est respecté, sinon ne s'exécute pas

Héritage
#+begin_src c
contract Zombiefactory {
}

contract ZombieFeeding is ZombieFactory {
}
#+end_src

import

#+begin_src c
  import "./zombiefactory.sol";
#+end_src


internal est similaire à private, à l'exception qu'elle est aussi accessible aux contrats qui héritent de ce contrat. (On dirait que c'est ce que l'on veut!).
external est similaire à public, à l'exception que ces fonctions peuvent SEULEMENT être appelées à l'extérieur du contrat - elles ne peuvent pas être appelées par d'autres fonctions à l'intérieur du contrat.


interface

#+begin_src c
  contract NumberInterface {
    function getNum(address _myAddress) public view returns (uint);
  }
  contract MyContract {
    address NumberInterfaceAddress = 0xab38...
    // ^ L'adresse du contrat FavoriteNumber sur Ethereum
    NumberInterface numberContract = NumberInterface(NumberInterfaceAddress)
    // Maintenant `numberContract` pointe vers l'autre contrat
#+end_src

Pour résumer le contrat Ownable fait fondamentalement ceci :

    Quand un contrat est créé, son constructeur défini le owner égal à msg.sender (la personne qui le déploie)

    Il ajoute un modificateur onlyOwner, qui permet de restreindre l'accès à certaines fonctions à seulement le owner

    Il vous permet de transférer le contrat à un nouvel owner



20 min

#+begin_src c
/**
 * @dev Abandonne si appelé par un compte autre que le `owner`.
 */
modifier onlyOwner() {
  require(msg.sender == owner);
  _;
}
#+end_src

Nous allons utiliser ce modificateur comme suit :

#+begin_src c
contract MyContract is Ownable {
  event LaughManiacally(string laughter);

  // Vous remarquerez l'usage de `onlyOwner` ci-dessous :
  function likeABoss() external onlyOwner {
    LaughManiacally("Muahahahaha");
  }
}

#+end_src

La variable now (maintenant) va retourner l'horodatage actuel unix

#+begin_src c
  // Un mappage pour stocker l'âge d'un utilisateur :
  mapping (uint => uint) public age;

  // Un modificateur qui nécessite que l'utilisateur soit plus âgé qu'un certain âge :
  modifier olderThan(uint _age, uint _userId) {
    require (age[_userId] >= _age);
    _;
  }
  // Doit avoir plus de 16 ans pour conduire une voiture (du moins, aux US).
  // Nous pouvons appeler le modificateur `olderThan` avec des arguments, comme :
  function driveCar(uint _userId) public olderThan(16, _userId) {
    // Logique de la fonction
  }
  function machin(param) payable  // signifie qu'on peut envoyer de l'argent à la fonction (à un contrat)
  // Ceux-ci sont stocker dans le compte Ether du contrat
#+end_src

Vous pouvez écrire une fonction pour retirer des Ether du contrat de cette manière :
#+begin_src C++ :noweb yes
contract GetPaid is Ownable {
  function withdraw() external onlyOwner {
    owner.transfer(this.balance);
  }
}
#+end_src

Vous pouvez transférer des Ether à une adresse en utilisant la fonction transfer, et this.balance retournera la balance totale stockée sur le contrat.
Si 100 utilisateurs ont payé 1 Ether à votre contrat, this.balance sera égal à 100 Ether.


vous pouvez avoir une fonction qui renvoie les Ether à msg.sender s'il paye trop cher pour un article :
#+begin_src C++ :noweb yes
uint itemFee = 0.001 ether;
msg.sender.transfer(msg.value - itemFee);
#+end_src

nb alea :
#+begin_src C++ :noweb yes
  uint randNonce = 0;

  function randMod(uint _modulus) internal returns(uint) {
    randNonce++;
    return uint(keccak256(now, msg.snder, randNonce)) % _modulus;
  }
#+end_src

#+begin_src C++ :noweb yes
import "./erc721.sol";
contract ZombieOwnership is ZombieAttack, ERC721 {

}
#+end_src

#+begin_src C++ :noweb yes
function _transfer(address _from, address _to, uint256 _tokenId) private {
    ownerZombieCount[_to]++;
    ownerZombieCount[_from]--;
    zombieToOwner[_tokenId] = _to;
    Transfer(_from, _to, _tokenId);
  }
#+end_src


